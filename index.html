<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>zipipo planner </title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for mobile-first design - Lavender Theme */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #fcfcfc; /* Very light ivory/off-white */
            color: #333;
            max-width: 600px;
            margin: 0 auto;
            padding: 1rem;
        }
        .container {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .input-group, .action-button {
            /* Soft Violet Shadow: Based on violet-400 */
            box-shadow: 0 4px 6px -1px rgba(167, 139, 250, 0.1), 0 2px 4px -2px rgba(167, 139, 250, 0.1);
        }
        .action-button {
            padding: 0.75rem 1rem;
            font-size: 1rem;
            font-weight: 600;
            border-radius: 0.75rem;
            transition: all 0.2s;
            cursor: pointer;
            width: 100%;
            margin-top: 0.5rem;
        }
        .schedule-item {
            padding: 0.75rem;
            border-radius: 0.5rem;
            background-color: #ffffff;
            /* Violet accent border */
            border-left: 5px solid #8b5cf6; /* Violet-500 accent */
        }
        .feedback-input {
            /* Light violet border */
            border: 1px solid #ddd6fe; /* Violet-200 border */
            padding: 0.5rem;
            border-radius: 0.5rem;
            margin-top: 0.5rem;
            width: 100%;
            font-size: 0.9rem;
        }
        /* Overriding Tailwind Checkbox color to Violet */
        input[type='checkbox'] {
            color: #7c3aed; /* Violet-600 */
        }
        /* Mobile-specific adjustments */
        @media (max-width: 640px) {
            body { padding: 0.5rem; }
            .action-button { font-size: 0.9rem; padding: 0.6rem; }
        }
    </style>
</head>
<body>

<div class="container">
    <!-- Title updated to "Time blocks" and color kept at text-violet-600 -->
    <h1 class="text-2xl font-bold text-center text-violet-600 py-4">Time blocks ğŸ’œ</h1>

    <!-- 1. API Key Input -->
    <div class="input-group bg-white p-4 rounded-xl">
        <label for="apiKey" class="block text-sm font-medium text-gray-700 mb-2 flex items-center">
            ğŸ”‘ OpenAI API Key (ì•”í˜¸í™” ì…ë ¥)
        </label>
        <!-- Focus ring and border color uses violet-500 -->
        <input type="password" id="apiKey" placeholder="ì—¬ê¸°ì— API Keyë¥¼ ì…ë ¥í•˜ì„¸ìš”" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-violet-500 focus:border-violet-500 text-sm">
    </div>

    <!-- 2. Mode Selector (Daily/Weekly) -->
    <div class="flex space-x-2 p-1 bg-white rounded-xl shadow">
        <!-- Mode buttons use violet-400 (base theme color) -->
        <button id="modeDaily" class="flex-1 py-3 font-semibold rounded-lg transition-colors bg-violet-400 text-white">Daily Planner</button>
        <button id="modeWeekly" class="flex-1 py-3 font-semibold rounded-lg transition-colors text-gray-600 hover:bg-violet-50 transition-colors">Weekly Planner</button>
    </div>

    <!-- 3. Task Input -->
    <div class="input-group bg-white p-4 rounded-xl">
        <label for="taskInput" class="block text-sm font-medium text-gray-700 mb-2 flex items-center">
            âœï¸ ì˜¤ëŠ˜/ì´ë²ˆ ì£¼ í•  ì¼ ëª©ë¡ (êµ¬ì²´ì ìœ¼ë¡œ ì‘ì„±)
        </label>
        <!-- Focus ring and border color uses violet-500 -->
        <textarea id="taskInput" rows="4" placeholder="ì˜ˆ: ì˜¤ëŠ˜ ì˜¤í”½ ê³µë¶€ 3ì‹œê°„, ì´ë©”ì¼ í™•ì¸ 1ì‹œê°„, í—¬ìŠ¤ì¥ ê°€ê¸°, ì €ë… ì‹ì‚¬ ì¤€ë¹„&#10;ì£¼ê°„: í”„ë¡œì íŠ¸ ê¸°íšì•ˆ ë§ˆë¬´ë¦¬, ì±… 1ê¶Œ ì½ê¸°" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-violet-500 focus:border-violet-500 text-sm"></textarea>
    </div>

    <!-- 4. Action Buttons (All unified to Violet theme) -->
    <div class="grid grid-cols-3 gap-2">
        <!-- Primary Action: Generate Schedule (Darker for emphasis) -->
        <button id="generateBtn" class="action-button bg-violet-500 text-white hover:bg-violet-600 active:bg-violet-700 col-span-3 flex items-center justify-center">
            ğŸš€ Generate Schedule
        </button>
        <!-- Secondary Actions: Save, Load, Clear (Brighter/Lighter for softer look) -->
        <!-- Unified color: bg-violet-300 for base, text-violet-800 for contrast -->
        <button id="saveBtn" class="action-button bg-violet-300 text-violet-800 hover:bg-violet-400 hover:text-white active:bg-violet-500">
            ğŸ’¾ Save
        </button>
        <button id="loadBtn" class="action-button bg-violet-300 text-violet-800 hover:bg-violet-400 hover:text-white active:bg-violet-500">
            ğŸ“ Load
        </button>
        <button id="clearBtn" class="action-button bg-violet-300 text-violet-800 hover:bg-violet-400 hover:text-white active:bg-violet-500">
            âŒ Clear
        </button>
    </div>
    
    <!-- 5. Status & Loading Message -->
    <div id="statusMessage" class="text-center p-3 text-sm font-medium text-gray-500 min-h-[20px]"></div>

    <!-- 6. Achievement Score (New Feature) -->
    <div id="achievementDisplay" class="bg-yellow-100 p-3 rounded-xl text-center font-bold text-yellow-800 hidden">
        ğŸ”¥ ìµœì¢… ì„±ì·¨ë„: <span id="achievementScore">0%</span> ë‹¬ì„±!
    </div>

    <!-- 7. Schedule Output Area -->
    <!-- Schedule output background uses a very light violet-50 -->
    <div id="scheduleOutput" class="space-y-3 p-4 bg-violet-50 rounded-xl min-h-[150px]">
        <h3 class="text-lg font-semibold text-gray-600 text-center">AI ìƒì„± ìŠ¤ì¼€ì¤„ì´ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.</h3>
    </div>
</div>

<script>
    // Constants
    const OPENAI_API_URL = 'https://api.openai.com/v1/chat/completions';
    const LOCAL_STORAGE_KEY = 'gptSmartPlannerSchedules';
    
    // DOM Elements
    const apiKeyInput = document.getElementById('apiKey');
    const taskInput = document.getElementById('taskInput');
    const scheduleOutput = document.getElementById('scheduleOutput');
    const statusMessage = document.getElementById('statusMessage');
    const achievementDisplay = document.getElementById('achievementDisplay');
    const achievementScore = document.getElementById('achievementScore');
    const modeDailyBtn = document.getElementById('modeDaily');
    const modeWeeklyBtn = document.getElementById('modeWeekly');
    
    // State
    let currentMode = 'daily'; // 'daily' or 'weekly'
    let currentSchedule = []; // The currently displayed, parsed schedule (for saving)
    let feedbackHistory = []; // Loaded from localStorage, used for prompt
    
    // --- Utility Functions ---

    /**
     * Shows a message temporarily in the status bar.
     * @param {string} msg 
     * @param {boolean} isError 
     */
    function showStatus(msg, isError = false) {
        statusMessage.textContent = msg;
        statusMessage.className = `text-center p-3 text-sm font-medium min-h-[20px] ${isError ? 'text-red-600' : 'text-green-600'}`;
        setTimeout(() => {
            statusMessage.textContent = '';
            statusMessage.className = 'text-center p-3 text-sm font-medium text-gray-500 min-h-[20px]';
        }, 3000);
    }

    /**
     * Fetches feedback history from localStorage.
     */
    function loadFeedbackHistory() {
        const storedData = localStorage.getItem(LOCAL_STORAGE_KEY);
        if (storedData) {
            feedbackHistory = JSON.parse(storedData).filter(item => item.feedback && item.feedback.trim() !== '');
        } else {
            feedbackHistory = [];
        }
        console.log("Loaded Feedback History:", feedbackHistory);
    }
    
    /**
     * Saves the current schedule and all history to localStorage.
     */
    function saveSchedule() {
        if (currentSchedule.length === 0) {
            return showStatus('ì €ì¥í•  ìŠ¤ì¼€ì¤„ì´ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € ìƒì„±í•´ì£¼ì„¸ìš”.', true);
        }

        // 1. Gather current user feedback from the UI before saving
        const taskElements = scheduleOutput.querySelectorAll('.schedule-item'); // Get all schedule items
        const feedbackElements = scheduleOutput.querySelectorAll('.feedback-input');

        const tasksWithFeedback = currentSchedule.map((task, index) => {
            const feedbackText = feedbackElements[index] ? feedbackElements[index].value : '';
            // Check the current state of the checkbox in the UI
            const isCompleted = taskElements[index]?.querySelector('input[type="checkbox"]')?.checked || false;
            return { ...task, userFeedback: feedbackText, isCompleted: isCompleted };
        });
        
        // 2. Prepare feedback for the history (only aggregate the main feedback text)
        const aggregatedFeedback = Array.from(feedbackElements)
                                        .map(el => el.value.trim())
                                        .filter(f => f.length > 0)
                                        .join(' / ');


        // 3. Create the new historical entry
        const newEntry = {
            date: new Date().toISOString().substring(0, 10),
            mode: currentMode,
            tasks: tasksWithFeedback,
            feedback: aggregatedFeedback,
            // Use the raw task input as raw schedule text for better regeneration on load
            rawScheduleText: taskInput.value.trim(), 
        };

        // 4. Update the history array (appending the new, detailed entry)
        const storedData = localStorage.getItem(LOCAL_STORAGE_KEY);
        let history = storedData ? JSON.parse(storedData) : [];
        
        // Always add a new entry when saving, as it reflects the current session's feedback and task list.
        history.push(newEntry);

        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(history));
        loadFeedbackHistory(); // Reload history for the next prompt
        showStatus('âœ… í˜„ì¬ ìŠ¤ì¼€ì¤„ê³¼ í”¼ë“œë°±ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.');
        calculateAchievement();
    }
    
    /**
     * Loads and displays a list of saved schedules for the user to choose.
     */
    function loadSchedules() {
        const storedData = localStorage.getItem(LOCAL_STORAGE_KEY);
        const history = storedData ? JSON.parse(storedData) : [];
        
        if (history.length === 0) {
            return showStatus('ì €ì¥ëœ ìŠ¤ì¼€ì¤„ì´ ì—†ìŠµë‹ˆë‹¤.', true);
        }

        // Output header uses violet-700
        scheduleOutput.innerHTML = `<h3 class="text-xl font-bold mb-4 text-violet-700">ğŸ“‚ ì €ì¥ëœ ìŠ¤ì¼€ì¤„ ëª©ë¡</h3>`;
        
        history.reverse().forEach((item, index) => {
            const dateStr = item.date;
            const modeStr = item.mode === 'daily' ? 'ì¼ê°„' : 'ì£¼ê°„';
            
            // Item background uses violet-100, text uses violet-800, hover uses violet-200
            const loadBtn = document.createElement('button');
            loadBtn.className = 'w-full text-left p-3 my-2 bg-violet-100 text-violet-800 rounded-lg hover:bg-violet-200 transition-colors';
            loadBtn.innerHTML = `<strong>${modeStr} í”Œë˜ë„ˆ (${dateStr})</strong><br><span class="text-sm text-gray-600">ìµœê·¼ í”¼ë“œë°±: ${item.feedback || 'ì—†ìŒ'}</span>`;
            
            loadBtn.onclick = () => {
                // Load the schedule back into the main view
                currentMode = item.mode;
                // Use the saved raw schedule text to populate the task input
                taskInput.value = item.rawScheduleText; 
                renderSchedule(item.tasks); // Render the detailed tasks with completion/feedback
                
                // Update mode button visually
                if (currentMode === 'daily') {
                    modeDailyBtn.click();
                } else {
                    modeWeeklyBtn.click();
                }
                
                showStatus(`âœ… ${dateStr} ìŠ¤ì¼€ì¤„ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤. ìˆ˜ì • í›„ ì €ì¥í•˜ê±°ë‚˜ ìƒˆë¡œ ìƒì„±í•˜ì„¸ìš”.`);
            };

            scheduleOutput.appendChild(loadBtn);
        });

        // Ensure the current schedule is cleared when loading the list
        currentSchedule = [];
        achievementDisplay.classList.add('hidden'); // Hide achievement display when showing list
    }

    /**
     * Parses the raw text output from GPT and renders the interactive UI.
     * @param {string | Array<Object>} scheduleData - Raw text or pre-parsed array (for loading).
     */
    function renderSchedule(scheduleData) {
        if (typeof scheduleData === 'string') {
            // Case: New schedule generation (from raw text)
            const lines = scheduleData.split('\n').filter(line => line.trim());
            currentSchedule = lines.map(line => ({
                text: line.trim(),
                userFeedback: '',
                isCompleted: false
            }));
        } else {
            // Case: Loading from saved data (already parsed array)
            currentSchedule = scheduleData;
        }

        // Output header uses violet-700
        scheduleOutput.innerHTML = `<h3 class="text-xl font-bold mb-4 text-violet-700">âœ¨ AI ìƒì„± ${currentMode === 'daily' ? 'ì¼ê°„' : 'ì£¼ê°„'} ìŠ¤ì¼€ì¤„</h3>`;
        
        const listContainer = document.createElement('div');
        listContainer.className = 'space-y-3';

        currentSchedule.forEach((task) => {
            const itemDiv = document.createElement('div');
            // The .schedule-item class already has the violet border-left
            itemDiv.className = 'schedule-item flex flex-col gap-2'; 

            // 1. Checkbox and Task Text
            const taskContent = document.createElement('div');
            taskContent.className = 'flex items-start flex-1';
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.checked = task.isCompleted;
            // Checkbox uses violet-500
            checkbox.className = 'mt-1 mr-3 h-5 w-5 border-gray-300 rounded focus:ring-violet-500 flex-shrink-0 appearance-none border-2 checked:bg-violet-500 checked:border-violet-500';
            checkbox.onchange = calculateAchievement;
            
            const taskText = document.createElement('span');
            taskText.className = 'text-gray-800 font-medium break-words';
            taskText.textContent = task.text;

            taskContent.appendChild(checkbox);
            taskContent.appendChild(taskText);
            
            // 2. Feedback Input
            const feedbackLabel = document.createElement('label');
            feedbackLabel.className = 'text-xs text-gray-500 mt-2 block';
            feedbackLabel.textContent = 'ì‹¤ì œ ì„±ê³¼/í”¼ë“œë°± (ì˜ˆ: 30ë¶„ì€ ëª¨ìëë‹¤, ì§‘ì¤‘ ì–´ë ¤ì› ë‹¤)';

            const feedbackInput = document.createElement('textarea');
            // .feedback-input class has been updated to use light violet border
            feedbackInput.className = 'feedback-input resize-none h-12';
            feedbackInput.placeholder = 'í”¼ë“œë°±ì„ ì‘ì„±í•˜ì„¸ìš”... (ë‹¤ìŒ ê³„íšì— ë°˜ì˜ë©ë‹ˆë‹¤)';
            // Ensure the feedback value is displayed if loading a saved task
            feedbackInput.value = task.userFeedback || '';
            
            itemDiv.appendChild(taskContent);
            itemDiv.appendChild(feedbackLabel);
            itemDiv.appendChild(feedbackInput);
            
            listContainer.appendChild(itemDiv);
        });
        
        scheduleOutput.appendChild(listContainer);
        calculateAchievement(); // Initial calculation
    }

    /**
     * Calculates and displays the achievement score based on checked tasks.
     */
    function calculateAchievement() {
        // Need to query the current checkboxes displayed in the rendered schedule
        const checkboxes = scheduleOutput.querySelectorAll('.schedule-item input[type="checkbox"]');
        const totalTasks = checkboxes.length;
        if (totalTasks === 0) {
            achievementDisplay.classList.add('hidden');
            return;
        }

        const completedTasks = Array.from(checkboxes).filter(cb => cb.checked).length;
        const score = Math.round((completedTasks / totalTasks) * 100);

        achievementScore.textContent = `${score}%`;
        achievementDisplay.classList.remove('hidden');

        // Optional: Change background based on score (Pastel Colors)
        achievementDisplay.classList.remove('bg-yellow-100', 'bg-red-100', 'bg-green-100', 'text-red-800', 'text-yellow-800', 'text-green-800');
        if (score < 50) {
            achievementDisplay.classList.add('bg-red-100', 'text-red-800'); // Pastel Red for low
        } else if (score < 80) {
            achievementDisplay.classList.add('bg-yellow-100', 'text-yellow-800'); // Pastel Yellow for mid
        } else {
            achievementDisplay.classList.add('bg-green-100', 'text-green-800'); // Pastel Green for high
        }
    }


    /**
     * Constructs the system prompt for GPT, including historical feedback.
     */
    function constructSystemPrompt(mode, history) {
        let historyContext = "";
        
        // Only use the last 3 non-empty feedback entries
        const recentFeedback = history.filter(item => item.feedback && item.feedback.trim() !== '').slice(-3);
        
        if (recentFeedback.length > 0) {
            historyContext = "ì‚¬ìš©ìì˜ ê³¼ê±° í”¼ë“œë°±ì„ ë°˜ë“œì‹œ ë°˜ì˜í•˜ì—¬ ë‹¤ìŒ ìŠ¤ì¼€ì¤„ì— 'í•™ìŠµ' íš¨ê³¼ë¥¼ ì ìš©í•´ì•¼ í•©ë‹ˆë‹¤. ë‹¤ìŒì€ ìµœê·¼ í”¼ë“œë°± ìš”ì•½ì…ë‹ˆë‹¤:\n";
            recentFeedback.forEach(f => {
                historyContext += `- [${f.date} í”¼ë“œë°±]: ${f.feedback}\n`;
            });
            historyContext += "\n";
        }

        const basePrompt = `ë‹¹ì‹ ì€ ê°œì¸ ë§ì¶¤í˜• AI í”Œë˜ë„ˆì…ë‹ˆë‹¤. ì‚¬ìš©ìê°€ ìš”ì²­í•œ í•  ì¼ì„ ê¸°ë°˜ìœ¼ë¡œ ì‹œê°„ ê¸°ë°˜ ì¼ì •í‘œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
        
        **í•µì‹¬ ê·œì¹™:**
        1. ì‹œê°„ ê¸°ë°˜ ì¼ì •í‘œë§Œ ì¶œë ¥í•˜ë©°, ë¶ˆí•„ìš”í•œ ì„¤ëª…, ì„œë¡ , ê²°ë¡ ì€ **ì ˆëŒ€** í¬í•¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì˜¤ì§ 'ì‹œê°„ ~ ì‹œê°„ í™œë™ëª…' ë˜ëŠ” 'ìš”ì¼: í™œë™ëª…' í˜•íƒœì˜ ì¼ì •ë§Œ ì¶œë ¥í•©ë‹ˆë‹¤.
        2. ì¥ì‹œê°„ ì¼ì •(2ì‹œê°„ ì´ìƒ)ì—ëŠ” 10~15ë¶„ íœ´ì‹ ì‹œê°„(ì˜ˆ: 10:30 ~ 10:45 ğŸ˜´ íœ´ì‹)ì„ ìë™ìœ¼ë¡œ í¬í•¨í•©ë‹ˆë‹¤.
        3. í™œë™ì— ì ì ˆí•œ ì´ëª¨ì§€(ì˜ˆ: ğŸ“š ê³µë¶€, ğŸƒ ìš´ë™, ğŸ½ï¸ ì‹ì‚¬, ğŸ’» ì—…ë¬´, ğŸ  ê°€ì‚¬, ğŸ’¤ íœ´ì‹/ìˆ˜ë©´)ë¥¼ ì¹´í…Œê³ ë¦¬ë³„ë¡œ í†µì¼í•˜ì—¬ ì‚¬ìš©í•©ë‹ˆë‹¤.
        4. ${mode === 'daily' ? 'ì˜¤ëŠ˜ì˜ ì‹œê°„ë³„ ì¼ì •í‘œë¥¼ **ìƒì„¸íˆ** ì‘ì„±í•©ë‹ˆë‹¤. (í•˜ë£¨ ì¤‘ 8ì‹œê°„ ì´ìƒì˜ í™œë™ì„ ì±„ìš°ëŠ” ê²ƒì„ ëª©í‘œë¡œ í•©ë‹ˆë‹¤.)' : 'ì´ë²ˆ ì£¼ì˜ ìš°ì„ ìˆœìœ„ë¥¼ ì•Œì•„ì„œ ë°°ì—´í•˜ì—¬ ìš”ì¼ë³„ë¡œ í•  ì¼ì„ ì±„ì›ë‹ˆë‹¤. (ì›”ìš”ì¼ë¶€í„° ì¼ìš”ì¼ê¹Œì§€ ìš”ì¼ë³„ë¡œ êµ¬ë¶„í•˜ì—¬ ì¶œë ¥)'}
        5. ${historyContext} ê³¼ê±° í”¼ë“œë°±ì„ ë¶„ì„í•˜ì—¬ ë‹¤ìŒ ê³„íšì˜ ì‹œê°„ ë°°ë¶„ì´ë‚˜ íœ´ì‹ ì¶”ê°€ ë“±ì— **ìë™ìœ¼ë¡œ ë°˜ì˜**í•´ì•¼ í•©ë‹ˆë‹¤. (ì˜ˆ: '30ë¶„ì€ ì§§ì•˜ë‹¤' -> ë‹¤ìŒ ìŠ¤ì¼€ì¤„ì— í•´ë‹¹ í™œë™ ì‹œê°„ì„ ëŠ˜ë¦¼)

        ìš”ì²­ëœ í•  ì¼ ëª©ë¡ê³¼ ëª¨ë“œ(${mode})ì— ë§ì¶° ì¼ì •ì„ ìƒì„±í•˜ì„¸ìš”.`;

        return basePrompt;
    }


    // --- Core Function: GPT Call ---
    
    /**
     * Handles API key validation and calls the OpenAI API with exponential backoff.
     */
    async function generateSchedule() {
        const apiKey = apiKeyInput.value.trim();
        const tasks = taskInput.value.trim();

        if (!apiKey) {
            return showStatus('ğŸ”‘ OpenAI API Keyë¥¼ ë¨¼ì € ì…ë ¥í•´ì£¼ì„¸ìš”.', true);
        }
        if (!tasks) {
            return showStatus('ğŸ“ í•  ì¼ ëª©ë¡ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.', true);
        }

        statusMessage.textContent = 'ğŸš€ AI ìŠ¤ì¼€ì¤„ ìƒì„± ì¤‘... (ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”)';
        statusMessage.classList.remove('text-green-600', 'text-red-600');
        // Loading text color uses violet-600
        statusMessage.classList.add('text-violet-600'); 
        
        const systemPrompt = constructSystemPrompt(currentMode, feedbackHistory);

        const MAX_RETRIES = 3;
        for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
            try {
                const response = await fetch(OPENAI_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-3.5-turbo', // or 'gpt-4o' for higher quality/cost
                        messages: [
                            { role: 'system', content: systemPrompt },
                            { role: 'user', content: `ë‚˜ì˜ í•  ì¼ ëª©ë¡: ${tasks}` }
                        ],
                        temperature: 0.7
                    })
                });

                if (!response.ok) {
                    // If status is 429 (Rate Limit), attempt retry
                    if (response.status === 429 && attempt < MAX_RETRIES - 1) {
                        const delay = Math.pow(2, attempt) * 1000; // Exponential backoff: 1s, 2s, 4s
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue; // Skip the rest of the loop and try again
                    }
                    const errorData = await response.json();
                    console.error("API Error:", errorData);
                    throw new Error(`API í˜¸ì¶œ ì‹¤íŒ¨: ${response.status} ${errorData.error ? errorData.error.message : response.statusText}`);
                }

                const data = await response.json();
                const rawText = data.choices[0].message.content.trim();
                
                if (rawText) {
                    renderSchedule(rawText);
                    showStatus('âœ… ìŠ¤ì¼€ì¤„ì´ ì„±ê³µì ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤. í”¼ë“œë°±ì„ ê¸°ë¡í•˜ê³  ì €ì¥í•˜ì„¸ìš”!');
                } else {
                    showStatus('âš ï¸ AIê°€ ìœ íš¨í•œ ìŠ¤ì¼€ì¤„ì„ ìƒì„±í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. í•  ì¼ ëª©ë¡ì„ êµ¬ì²´ì ìœ¼ë¡œ ì‘ì„±í•´ ë³´ì„¸ìš”.', true);
                }
                return; // Exit function on success
                
            } catch (error) {
                if (attempt === MAX_RETRIES - 1) {
                    console.error(error);
                    showStatus(`âŒ ì˜¤ë¥˜ ë°œìƒ: ${error.message}. API Key ë˜ëŠ” ë„¤íŠ¸ì›Œí¬ë¥¼ í™•ì¸í•˜ì„¸ìš”.`, true);
                }
                // If it was a 429 handled by the loop, the error is suppressed until max retries reached.
            }
        }
        // If execution reaches here, it means all retries failed.
        statusMessage.classList.remove('text-violet-600');
    }


    // --- Event Listeners ---

    // Mode Selector
    modeDailyBtn.addEventListener('click', () => {
        currentMode = 'daily';
        // Active mode uses violet-400
        modeDailyBtn.classList.add('bg-violet-400', 'text-white');
        modeDailyBtn.classList.remove('text-gray-600', 'hover:bg-violet-50');
        modeWeeklyBtn.classList.remove('bg-violet-400', 'text-white');
        modeWeeklyBtn.classList.add('text-gray-600', 'hover:bg-violet-50');
        showStatus('ì¼ê°„ í”Œë˜ë„ˆ ëª¨ë“œë¡œ ì „í™˜ë˜ì—ˆìŠµë‹ˆë‹¤.');
    });

    modeWeeklyBtn.addEventListener('click', () => {
        currentMode = 'weekly';
        // Active mode uses violet-400
        modeWeeklyBtn.classList.add('bg-violet-400', 'text-white');
        modeWeeklyBtn.classList.remove('text-gray-600', 'hover:bg-violet-50');
        modeDailyBtn.classList.remove('bg-violet-400', 'text-white');
        modeDailyBtn.classList.add('text-gray-600', 'hover:bg-violet-50');
        showStatus('ì£¼ê°„ í”Œë˜ë„ˆ ëª¨ë“œë¡œ ì „í™˜ë˜ì—ˆìŠµë‹ˆë‹¤.');
    });

    // Action Buttons
    document.getElementById('generateBtn').addEventListener('click', generateSchedule);
    document.getElementById('saveBtn').addEventListener('click', saveSchedule);
    document.getElementById('loadBtn').addEventListener('click', loadSchedules);
    document.getElementById('clearBtn').addEventListener('click', () => {
        // Clear all UI inputs and state
        apiKeyInput.value = '';
        taskInput.value = '';
        scheduleOutput.innerHTML = `<h3 class="text-lg font-semibold text-gray-600 text-center">AI ìƒì„± ìŠ¤ì¼€ì¤„ì´ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.</h3>`;
        currentSchedule = [];
        achievementDisplay.classList.add('hidden');
        showStatus('ëª¨ë“  ë‚´ìš©ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤. (ì €ì¥ëœ ê¸°ë¡ì€ ìœ ì§€)');
    });


    // --- Initialization ---
    window.onload = () => {
        loadFeedbackHistory();
        console.log("App Initialized. Feedback history loaded for AI learning.");
        showStatus('âœ¨ í”Œë˜ë„ˆ ì¤€ë¹„ ì™„ë£Œ! Keyì™€ í•  ì¼ì„ ì…ë ¥í•˜ì„¸ìš”.');
    };
    
</script>

</body>
</html>