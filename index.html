<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>zipipo planner</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for mobile-first design - Light Pink Theme */
        body {
            font-family: 'Inter', sans-serif;
            font-weight: 300; /* ì–‡ì€ ê¸€ì”¨ì²´ ì„¤ì • (Light) */
            background-color: #fcfcfc; /* Very light ivory/off-white */
            color: #333;
            max-width: 600px;
            margin: 0 auto;
            padding: 1rem;
        }
        .container {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .input-group, .action-button {
            /* Soft Rose Shadow: Based on rose-400 */
            box-shadow: 0 4px 6px -1px rgba(251, 113, 133, 0.1), 0 2px 4px -2px rgba(251, 113, 133, 0.1);
        }
        .action-button {
            padding: 0.75rem 1rem;
            font-size: 1rem;
            font-weight: 500; /* Medium weight for button text */
            border-radius: 0.75rem;
            transition: all 0.2s;
            cursor: pointer;
            width: 100%;
            margin-top: 0.5rem;
        }
        .schedule-item {
            padding: 0.75rem;
            border-radius: 0.5rem;
            background-color: #ffffff;
            /* Accent border uses the requested color #FEE1E8 */
            border-left: 5px solid #FEE1E8; 
        }
        .feedback-input {
            /* Light rose border (rose-200 equivalent) */
            border: 1px solid #fbcfe8; 
            padding: 0.5rem;
            border-radius: 0.5rem;
            margin-top: 0.5rem;
            width: 100%;
            font-size: 0.9rem;
        }
        /* Overriding Tailwind Checkbox color to Rose-600 */
        input[type='checkbox'] {
            color: #e11d48; /* Rose-600 */
        }
        /* Mobile-specific adjustments */
        @media (max-width: 640px) {
            body { padding: 0.5rem; }
            .action-button { font-size: 0.9rem; padding: 0.6rem; }
        }
    </style>
</head>
<body>

<div class="container">
    <!-- Title updated and heart removed. Color changed to rose-600. -->
    <h1 class="text-2xl font-bold text-center text-rose-600 py-4">zipipo planner</h1>

    <!-- 1. API Key Input -->
    <div class="input-group bg-white p-4 rounded-xl">
        <label for="apiKey" class="block text-sm font-medium text-gray-700 mb-2 flex items-center">
            ğŸ”‘ Gemini API Key (ì•”í˜¸í™” ì…ë ¥)
        </label>
        <!-- Focus ring and border color uses rose-500 -->
        <input type="password" id="apiKey" placeholder="ì—¬ê¸°ì— Gemini API Keyë¥¼ ì…ë ¥í•˜ì„¸ìš”" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-rose-500 focus:border-rose-500 text-sm">
    </div>

    <!-- 2. Mode Selector (Daily/Weekly) -->
    <div class="flex space-x-2 p-1 bg-white rounded-xl shadow">
        <!-- Mode buttons use rose-400 (base theme color) -->
        <button id="modeDaily" class="flex-1 py-3 font-semibold rounded-lg transition-colors bg-rose-400 text-white">Daily Planner</button>
        <button id="modeWeekly" class="flex-1 py-3 font-semibold rounded-lg transition-colors text-gray-600 hover:bg-rose-50 transition-colors">Weekly Planner</button>
    </div>

    <!-- 3. Task Input -->
    <div class="input-group bg-white p-4 rounded-xl">
        <label for="taskInput" class="block text-sm font-medium text-gray-700 mb-2 flex items-center">
            âœï¸ ì˜¤ëŠ˜/ì´ë²ˆ ì£¼ í•  ì¼ ëª©ë¡ (êµ¬ì²´ì ìœ¼ë¡œ ì‘ì„±)
        </label>
        <!-- Focus ring and border color uses rose-500 -->
        <textarea id="taskInput" rows="4" placeholder="ì˜ˆ: ì˜¤ëŠ˜ ì˜¤í”½ ê³µë¶€ 3ì‹œê°„, ì´ë©”ì¼ í™•ì¸ 1ì‹œê°„, í—¬ìŠ¤ì¥ ê°€ê¸°, ì €ë… ì‹ì‚¬ ì¤€ë¹„&#10;ì£¼ê°„: í”„ë¡œì íŠ¸ ê¸°íšì•ˆ ë§ˆë¬´ë¦¬, ì±… 1ê¶Œ ì½ê¸°" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-rose-500 focus:border-rose-500 text-sm"></textarea>
    </div>

    <!-- 4. Action Buttons (All unified to Rose theme) -->
    <div class="grid grid-cols-3 gap-2">
        <!-- Primary Action: Generate Schedule (Darker for emphasis) -->
        <button id="generateBtn" class="action-button bg-rose-500 text-white hover:bg-rose-600 active:bg-rose-700 col-span-3 flex items-center justify-center">
            ğŸš€ Generate Schedule
        </button>
        <!-- Secondary Actions: Save, Load, Clear (Brighter/Lighter for softer look) -->
        <!-- Unified color: bg-rose-300 for base, text-rose-800 for contrast -->
        <button id="saveBtn" class="action-button bg-rose-300 text-rose-800 hover:bg-rose-400 hover:text-white active:bg-rose-500">
            ğŸ’¾ Save
        </button>
        <button id="loadBtn" class="action-button bg-rose-300 text-rose-800 hover:bg-rose-400 hover:text-white active:bg-rose-500">
            ğŸ“ Load
        </button>
        <button id="clearBtn" class="action-button bg-rose-300 text-rose-800 hover:bg-rose-400 hover:text-white active:bg-rose-500">
            âŒ Clear
        </button>
    </div>
    
    <!-- 5. Status & Loading Message -->
    <div id="statusMessage" class="text-center p-3 text-sm font-medium text-gray-500 min-h-[20px]"></div>

    <!-- 6. Achievement Score (New Feature) -->
    <div id="achievementDisplay" class="bg-yellow-100 p-3 rounded-xl text-center font-bold text-yellow-800 hidden">
        ğŸ”¥ ìµœì¢… ì„±ì·¨ë„: <span id="achievementScore">0%</span> ë‹¬ì„±!
    </div>

    <!-- 7. Schedule Output Area -->
    <!-- Schedule output background uses a very light rose-50 -->
    <div id="scheduleOutput" class="space-y-3 p-4 bg-rose-50 rounded-xl min-h-[150px]">
        <h3 class="text-lg font-semibold text-gray-600 text-center">AI ìƒì„± ìŠ¤ì¼€ì¤„ì´ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.</h3>
    </div>
</div>

<script>
    // Constants: Updated to use Gemini API endpoint and model
    const GEMINI_MODEL = 'gemini-2.5-flash-preview-09-2025';
    const GEMINI_API_BASE_URL = 'https://generativelanguage.googleapis.com/v1beta/models/';
    const LOCAL_STORAGE_KEY = 'gptSmartPlannerSchedules';
    
    // DOM Elements
    const apiKeyInput = document.getElementById('apiKey');
    const taskInput = document.getElementById('taskInput');
    const scheduleOutput = document.getElementById('scheduleOutput');
    const statusMessage = document.getElementById('statusMessage');
    const achievementDisplay = document.getElementById('achievementDisplay');
    const achievementScore = document.getElementById('achievementScore');
    const modeDailyBtn = document.getElementById('modeDaily');
    const modeWeeklyBtn = document.getElementById('modeWeekly');
    
    // State
    let currentMode = 'daily'; // 'daily' or 'weekly'
    let currentSchedule = []; // The currently displayed, parsed schedule (for saving)
    let feedbackHistory = []; // Loaded from localStorage, used for prompt
    
    // --- Utility Functions ---

    /**
     * Shows a message temporarily in the status bar.
     * @param {string} msg 
     * @param {boolean} isError 
     */
    function showStatus(msg, isError = false) {
        statusMessage.textContent = msg;
        statusMessage.className = `text-center p-3 text-sm font-medium min-h-[20px] ${isError ? 'text-red-600' : 'text-green-600'}`;
        setTimeout(() => {
            statusMessage.textContent = '';
            statusMessage.className = 'text-center p-3 text-sm font-medium text-gray-500 min-h-[20px]';
        }, 3000);
    }

    /**
     * Fetches feedback history from localStorage.
     */
    function loadFeedbackHistory() {
        const storedData = localStorage.getItem(LOCAL_STORAGE_KEY);
        if (storedData) {
            feedbackHistory = JSON.parse(storedData).filter(item => item.feedback && item.feedback.trim() !== '');
        } else {
            feedbackHistory = [];
        }
        console.log("Loaded Feedback History:", feedbackHistory);
    }
    
    /**
     * Saves the current schedule and all history to localStorage.
     */
    function saveSchedule() {
        if (currentSchedule.length === 0) {
            return showStatus('ì €ì¥í•  ìŠ¤ì¼€ì¤„ì´ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € ìƒì„±í•´ì£¼ì„¸ìš”.', true);
        }

        // 1. Gather current user feedback from the UI before saving
        const taskElements = scheduleOutput.querySelectorAll('.schedule-item'); // Get all schedule items
        const feedbackElements = scheduleOutput.querySelectorAll('.feedback-input');

        const tasksWithFeedback = currentSchedule.map((task, index) => {
            const feedbackText = feedbackElements[index] ? feedbackElements[index].value : '';
            // Check the current state of the checkbox in the UI
            const isCompleted = taskElements[index]?.querySelector('input[type="checkbox"]')?.checked || false;
            return { ...task, userFeedback: feedbackText, isCompleted: isCompleted };
        });
        
        // 2. Prepare feedback for the history (only aggregate the main feedback text)
        const aggregatedFeedback = Array.from(feedbackElements)
                                        .map(el => el.value.trim())
                                        .filter(f => f.length > 0)
                                        .join(' / ');


        // 3. Create the new historical entry
        const newEntry = {
            date: new Date().toISOString().substring(0, 10),
            mode: currentMode,
            tasks: tasksWithFeedback,
            feedback: aggregatedFeedback,
            // Use the raw task input as raw schedule text for better regeneration on load
            rawScheduleText: taskInput.value.trim(), 
        };

        // 4. Update the history array (appending the new, detailed entry)
        const storedData = localStorage.getItem(LOCAL_STORAGE_KEY);
        let history = storedData ? JSON.parse(storedData) : [];
        
        // Always add a new entry when saving, as it reflects the current session's feedback and task list.
        history.push(newEntry);

        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(history));
        loadFeedbackHistory(); // Reload history for the next prompt
        showStatus('âœ… í˜„ì¬ ìŠ¤ì¼€ì¤„ê³¼ í”¼ë“œë°±ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.');
        calculateAchievement();
    }
    
    /**
     * Loads and displays a list of saved schedules for the user to choose.
     */
    function loadSchedules() {
        const storedData = localStorage.getItem(LOCAL_STORAGE_KEY);
        const history = storedData ? JSON.parse(storedData) : [];
        
        if (history.length === 0) {
            return showStatus('ì €ì¥ëœ ìŠ¤ì¼€ì¤„ì´ ì—†ìŠµë‹ˆë‹¤.', true);
        }

        // Output header uses rose-700
        scheduleOutput.innerHTML = `<h3 class="text-xl font-bold mb-4 text-rose-700">ğŸ“‚ ì €ì¥ëœ ìŠ¤ì¼€ì¤„ ëª©ë¡</h3>`;
        
        history.reverse().forEach((item, index) => {
            const dateStr = item.date;
            const modeStr = item.mode === 'daily' ? 'ì¼ê°„' : 'ì£¼ê°„';
            
            // Item background uses rose-100, text uses rose-800, hover uses rose-200
            const loadBtn = document.createElement('button');
            loadBtn.className = 'w-full text-left p-3 my-2 bg-rose-100 text-rose-800 rounded-lg hover:bg-rose-200 transition-colors';
            loadBtn.innerHTML = `<strong>${modeStr} í”Œë˜ë„ˆ (${dateStr})</strong><br><span class="text-sm text-gray-600">ìµœê·¼ í”¼ë“œë°±: ${item.feedback || 'ì—†ìŒ'}</span>`;
            
            loadBtn.onclick = () => {
                // Load the schedule back into the main view
                currentMode = item.mode;
                // Use the saved raw schedule text to populate the task input
                taskInput.value = item.rawScheduleText; 
                renderSchedule(item.tasks); // Render the detailed tasks with completion/feedback
                
                // Update mode button visually (uses rose colors)
                if (currentMode === 'daily') {
                    modeDailyBtn.classList.add('bg-rose-400', 'text-white');
                    modeDailyBtn.classList.remove('text-gray-600', 'hover:bg-rose-50');
                    modeWeeklyBtn.classList.remove('bg-rose-400', 'text-white');
                    modeWeeklyBtn.classList.add('text-gray-600', 'hover:bg-rose-50');
                } else {
                    modeWeeklyBtn.classList.add('bg-rose-400', 'text-white');
                    modeWeeklyBtn.classList.remove('text-gray-600', 'hover:bg-rose-50');
                    modeDailyBtn.classList.remove('bg-rose-400', 'text-white');
                    modeDailyBtn.classList.add('text-gray-600', 'hover:bg-rose-50');
                }
                
                showStatus(`âœ… ${dateStr} ìŠ¤ì¼€ì¤„ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤. ìˆ˜ì • í›„ ì €ì¥í•˜ê±°ë‚˜ ìƒˆë¡œ ìƒì„±í•˜ì„¸ìš”.`);
            };

            scheduleOutput.appendChild(loadBtn);
        });

        // Ensure the current schedule is cleared when loading the list
        currentSchedule = [];
        achievementDisplay.classList.add('hidden'); // Hide achievement display when showing list
    }

    /**
     * Parses the raw text output from GPT and renders the interactive UI.
     * @param {string | Array<Object>} scheduleData - Raw text or pre-parsed array (for loading).
     */
    function renderSchedule(scheduleData) {
        if (typeof scheduleData === 'string') {
            // Case: New schedule generation (from raw text)
            const lines = scheduleData.split('\n')
                .map(line => line.trim())
                // Filtering out empty lines AND lines that contain common separators or headers
                .filter(line => line.length > 0 && !line.includes('---')); 
                
            currentSchedule = lines.map(line => ({
                text: line, // use the trimmed line
                userFeedback: '',
                isCompleted: false
            }));
        } else {
            // Case: Loading from saved data (already parsed array)
            currentSchedule = scheduleData;
        }

        // Output header uses rose-700
        scheduleOutput.innerHTML = `<h3 class="text-xl font-bold mb-4 text-rose-700">âœ¨ AI ìƒì„± ${currentMode === 'daily' ? 'ì¼ê°„' : 'ì£¼ê°„'} ìŠ¤ì¼€ì¤„</h3>`;
        
        const listContainer = document.createElement('div');
        listContainer.className = 'space-y-3';

        currentSchedule.forEach((task) => {
            const itemDiv = document.createElement('div');
            // The .schedule-item class already has the #FEE1E8 accent border
            itemDiv.className = 'schedule-item flex flex-col gap-2'; 

            // 1. Checkbox and Task Text
            const taskContent = document.createElement('div');
            taskContent.className = 'flex items-start flex-1';
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.checked = task.isCompleted;
            // Checkbox uses rose-500
            checkbox.className = 'mt-1 mr-3 h-5 w-5 border-gray-300 rounded focus:ring-rose-500 flex-shrink-0 appearance-none border-2 checked:bg-rose-500 checked:border-rose-500';
            checkbox.onchange = calculateAchievement;
            
            const taskText = document.createElement('span');
            taskText.className = 'text-gray-800 font-medium break-words';
            taskText.textContent = task.text;

            taskContent.appendChild(checkbox);
            taskContent.appendChild(taskText);
            
            // 2. Feedback Input
            const feedbackLabel = document.createElement('label');
            feedbackLabel.className = 'text-xs text-gray-500 mt-2 block';
            feedbackLabel.textContent = 'ì‹¤ì œ ì„±ê³¼/í”¼ë“œë°± (ì˜ˆ: 30ë¶„ì€ ëª¨ìëë‹¤, ì§‘ì¤‘ ì–´ë ¤ì› ë‹¤)';

            const feedbackInput = document.createElement('textarea');
            // .feedback-input class has been updated to use light rose border
            feedbackInput.className = 'feedback-input resize-none h-12';
            feedbackInput.placeholder = 'í”¼ë“œë°±ì„ ì‘ì„±í•˜ì„¸ìš”... (ë‹¤ìŒ ê³„íšì— ë°˜ì˜ë©ë‹ˆë‹¤)';
            // Ensure the feedback value is displayed if loading a saved task
            feedbackInput.value = task.userFeedback || '';
            
            itemDiv.appendChild(taskContent);
            itemDiv.appendChild(feedbackLabel);
            itemDiv.appendChild(feedbackInput);
            
            listContainer.appendChild(itemDiv);
        });
        
        scheduleOutput.appendChild(listContainer);
        calculateAchievement(); // Initial calculation
    }

    /**
     * Calculates and displays the achievement score based on checked tasks.
     */
    function calculateAchievement() {
        // Need to query the current checkboxes displayed in the rendered schedule
        const checkboxes = scheduleOutput.querySelectorAll('.schedule-item input[type="checkbox"]');
        const totalTasks = checkboxes.length;
        if (totalTasks === 0) {
            achievementDisplay.classList.add('hidden');
            return;
        }

        const completedTasks = Array.from(checkboxes).filter(cb => cb.checked).length;
        const score = Math.round((completedTasks / totalTasks) * 100);

        achievementScore.textContent = `${score}%`;
        achievementDisplay.classList.remove('hidden');

        // Optional: Change background based on score (Pastel Colors)
        achievementDisplay.classList.remove('bg-yellow-100', 'bg-red-100', 'bg-green-100', 'text-red-800', 'text-yellow-800', 'text-green-800');
        if (score < 50) {
            achievementDisplay.classList.add('bg-red-100', 'text-red-800'); // Pastel Red for low
        } else if (score < 80) {
            achievementDisplay.classList.add('bg-yellow-100', 'text-yellow-800'); // Pastel Yellow for mid
        } else {
            achievementDisplay.classList.add('bg-green-100', 'text-green-800'); // Pastel Green for high
        }
    }


    /**
     * Constructs the system prompt for Gemini, including historical feedback.
     */
    function constructSystemPrompt(mode, history) {
        let historyContext = "";
        
        // Only use the last 3 non-empty feedback entries
        const recentFeedback = history.filter(item => item.feedback && item.feedback.trim() !== '').slice(-3);
        
        if (recentFeedback.length > 0) {
            historyContext = "ì‚¬ìš©ìì˜ ê³¼ê±° í”¼ë“œë°±ì„ ë°˜ë“œì‹œ ë°˜ì˜í•˜ì—¬ ë‹¤ìŒ ìŠ¤ì¼€ì¤„ì— 'í•™ìŠµ' íš¨ê³¼ë¥¼ ì ìš©í•´ì•¼ í•©ë‹ˆë‹¤. ë‹¤ìŒì€ ìµœê·¼ í”¼ë“œë°± ìš”ì•½ì…ë‹ˆë‹¤:\n";
            recentFeedback.forEach(f => {
                historyContext += `- [${f.date} í”¼ë“œë°±]: ${f.feedback}\n`;
            });
            historyContext += "\n";
        }

        const basePrompt = `ë‹¹ì‹ ì€ ê°œì¸ ë§ì¶¤í˜• AI í”Œë˜ë„ˆì…ë‹ˆë‹¤. ì‚¬ìš©ìê°€ ìš”ì²­í•œ í•  ì¼ì„ ê¸°ë°˜ìœ¼ë¡œ ì‹œê°„ ê¸°ë°˜ ì¼ì •í‘œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
        
        **í•µì‹¬ ê·œì¹™:**
        1. ì‹œê°„ ê¸°ë°˜ ì¼ì •í‘œë§Œ ì¶œë ¥í•˜ë©°, ë¶ˆí•„ìš”í•œ ì œëª©, ì„¤ëª…, ì„œë¡ , ê²°ë¡ , êµ¬ë¶„ì„ (--- ë“±)ì€ **ì ˆëŒ€** í¬í•¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì˜¤ì§ 'ì‹œê°„ ~ ì‹œê°„ í™œë™ëª… ì´ëª¨ì§€' ë˜ëŠ” 'ìš”ì¼: í™œë™ëª… ì´ëª¨ì§€' í˜•íƒœì˜ **ìˆœìˆ˜í•œ ì¼ì • ëª©ë¡**ë§Œ ì¶œë ¥í•©ë‹ˆë‹¤.
        2. ì¥ì‹œê°„ ì¼ì •(2ì‹œê°„ ì´ìƒ)ì—ëŠ” 10~15ë¶„ íœ´ì‹ ì‹œê°„(ì˜ˆ: 10:30 ~ 10:45 ğŸ˜´ íœ´ì‹)ì„ ìë™ìœ¼ë¡œ í¬í•¨í•©ë‹ˆë‹¤.
        3. í™œë™ì— ì ì ˆí•œ ì´ëª¨ì§€(ì˜ˆ: ğŸ“š ê³µë¶€, ğŸƒ ìš´ë™, ğŸ½ï¸ ì‹ì‚¬, ğŸ’» ì—…ë¬´, ğŸ  ê°€ì‚¬, ğŸ’¤ íœ´ì‹/ìˆ˜ë©´)ë¥¼ ì¹´í…Œê³ ë¦¬ë³„ë¡œ í†µì¼í•˜ì—¬ ì‚¬ìš©í•©ë‹ˆë‹¤.
        4. ${mode === 'daily' ? 'ì˜¤ëŠ˜ì˜ ì‹œê°„ë³„ ì¼ì •í‘œë¥¼ **ìƒì„¸íˆ** ì‘ì„±í•©ë‹ˆë‹¤. (í•˜ë£¨ ì¤‘ 8ì‹œê°„ ì´ìƒì˜ í™œë™ì„ ì±„ìš°ëŠ” ê²ƒì„ ëª©í‘œë¡œ í•©ë‹ˆë‹¤.)' : 'ì´ë²ˆ ì£¼ì˜ ìš°ì„ ìˆœìœ„ë¥¼ ì•Œì•„ì„œ ë°°ì—´í•˜ì—¬ ìš”ì¼ë³„ë¡œ í•  ì¼ì„ ì±„ì›ë‹ˆë‹¤. (ì›”ìš”ì¼ë¶€í„° ì¼ìš”ì¼ê¹Œì§€ ìš”ì¼ë³„ë¡œ êµ¬ë¶„í•˜ì—¬ ì¶œë ¥)'}
        5. **[ê°€ì¥ ì¤‘ìš”]** ì‚¬ìš©ìê°€ ëª…ì‹œí•œ í™œë™ ë° ì‹œê°„ ë²”ìœ„ë¥¼ **ì ˆëŒ€** ë²—ì–´ë‚˜ì§€ ë§ˆì„¸ìš”. ì‚¬ìš©ìê°€ ìš”ì²­í•˜ì§€ ì•Šì€ ì„ì˜ì˜ ì•„ì¹¨/ë°¤ í™œë™(ìˆ˜ë©´, ì•„ì¹¨ ì‹ì‚¬ ë“±)ì„ ì¶”ê°€í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

        ${historyContext} ê³¼ê±° í”¼ë“œë°±ì„ ë¶„ì„í•˜ì—¬ ë‹¤ìŒ ê³„íšì˜ ì‹œê°„ ë°°ë¶„ì´ë‚˜ íœ´ì‹ ì¶”ê°€ ë“±ì— **ìë™ìœ¼ë¡œ ë°˜ì˜**í•´ì•¼ í•©ë‹ˆë‹¤.
        
        ìš”ì²­ëœ í•  ì¼ ëª©ë¡ê³¼ ëª¨ë“œ(${mode})ì— ë§ì¶° ì¼ì •ì„ ìƒì„±í•˜ì„¸ìš”.`;

        return basePrompt;
    }


    // --- Core Function: Gemini API Call ---
    
    /**
     * Handles API key validation and calls the Gemini API with exponential backoff.
     */
    async function generateSchedule() {
        // NOTE: The apiKey variable here MUST contain the Gemini API Key.
        const apiKey = apiKeyInput.value.trim();
        const tasks = taskInput.value.trim();

        if (!apiKey) {
            // Updated message to reflect Gemini Key requirement
            return showStatus('ğŸ”‘ Gemini API Keyë¥¼ ë¨¼ì € ì…ë ¥í•´ì£¼ì„¸ìš”.', true);
        }
        if (!tasks) {
            return showStatus('ğŸ“ í•  ì¼ ëª©ë¡ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.', true);
        }

        statusMessage.textContent = 'ğŸš€ AI ìŠ¤ì¼€ì¤„ ìƒì„± ì¤‘... (ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”)';
        statusMessage.classList.remove('text-green-600', 'text-red-600');
        // Loading text color uses rose-600
        statusMessage.classList.add('text-rose-600'); 
        
        const systemPrompt = constructSystemPrompt(currentMode, feedbackHistory);
        const apiUrl = `${GEMINI_API_BASE_URL}${GEMINI_MODEL}:generateContent?key=${apiKey}`;

        const MAX_RETRIES = 3;
        for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
            try {
                // Gemini API Payload Structure
                const payload = {
                    contents: [{ 
                        parts: [{ text: `ë‚˜ì˜ í•  ì¼ ëª©ë¡: ${tasks}` }] 
                    }],
                    systemInstruction: { 
                        parts: [{ text: systemPrompt }] 
                    },
                    // FIX: Changed 'config' to 'generationConfig' to resolve the 400 error.
                    generationConfig: { 
                        temperature: 0.7 
                    }
                };
                
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    // --- ENHANCED ERROR HANDLING ---
                    const errorData = await response.json();
                    let errorMessage = '';
                    
                    if (errorData.error && errorData.error.message) {
                        // Extract specific message from API response
                        errorMessage = errorData.error.message;
                    } else {
                        // Fallback to status text
                        errorMessage = response.statusText || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜';
                    }

                    // Check for rate limit (429) and implement exponential backoff
                    if (response.status === 429 && attempt < MAX_RETRIES - 1) {
                        const delay = Math.pow(2, attempt) * 1000; // Exponential backoff: 1s, 2s, 4s
                        await new Promise(resolve => setTimeout(resolve, delay));
                        // Continue to the next retry attempt
                        continue; 
                    }

                    // For any other final error (400, 401, 500 etc.), throw the specific message
                    // We also include the status code for better context
                    throw new Error(`[Status: ${response.status}] ${errorMessage}`);
                }

                const data = await response.json();
                
                // Extracting text from Gemini response structure
                const rawText = data.candidates?.[0]?.content?.parts?.[0]?.text?.trim();
                
                if (rawText) {
                    renderSchedule(rawText);
                    showStatus('âœ… ìŠ¤ì¼€ì¤„ì´ ì„±ê³µì ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤. í”¼ë“œë°±ì„ ê¸°ë¡í•˜ê³  ì €ì¥í•˜ì„¸ìš”!');
                } else {
                    showStatus('âš ï¸ AIê°€ ìœ íš¨í•œ ìŠ¤ì¼€ì¤„ì„ ìƒì„±í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. í•  ì¼ ëª©ë¡ì„ êµ¬ì²´ì ìœ¼ë¡œ ì‘ì„±í•´ ë³´ì„¸ìš”.', true);
                }
                return; // Exit function on success
                
            } catch (error) {
                if (attempt === MAX_RETRIES - 1) {
                    // Display the specific error message caught
                    console.error("Final API Call Error:", error);
                    let displayMessage = `âŒ API í˜¸ì¶œ ì˜¤ë¥˜: ${error.message}. Key ë˜ëŠ” ë„¤íŠ¸ì›Œí¬ë¥¼ í™•ì¸í•˜ì„¸ìš”.`;
                        
                    showStatus(displayMessage, true);
                }
                // If it's not the final attempt, the 'continue' logic handles the retry.
            }
        }
        // If execution reaches here, it means all retries failed.
        statusMessage.classList.remove('text-rose-600');
    }


    // --- Event Listeners ---

    // Mode Selector
    modeDailyBtn.addEventListener('click', () => {
        currentMode = 'daily';
        // Active mode uses rose-400
        modeDailyBtn.classList.add('bg-rose-400', 'text-white');
        modeDailyBtn.classList.remove('text-gray-600', 'hover:bg-rose-50');
        modeWeeklyBtn.classList.remove('bg-rose-400', 'text-white');
        modeWeeklyBtn.classList.add('text-gray-600', 'hover:bg-rose-50');
        showStatus('ì¼ê°„ í”Œë˜ë„ˆ ëª¨ë“œë¡œ ì „í™˜ë˜ì—ˆìŠµë‹ˆë‹¤.');
    });

    modeWeeklyBtn.addEventListener('click', () => {
        currentMode = 'weekly';
        // Active mode uses rose-400
        modeWeeklyBtn.classList.add('bg-rose-400', 'text-white');
        modeWeeklyBtn.classList.remove('text-gray-600', 'hover:bg-rose-50');
        modeDailyBtn.classList.remove('bg-rose-400', 'text-white');
        modeDailyBtn.classList.add('text-gray-600', 'hover:bg-rose-50');
        showStatus('ì£¼ê°„ í”Œë˜ë„ˆ ëª¨ë“œë¡œ ì „í™˜ë˜ì—ˆìŠµë‹ˆë‹¤.');
    });

    // Action Buttons
    document.getElementById('generateBtn').addEventListener('click', generateSchedule);
    document.getElementById('saveBtn').addEventListener('click', saveSchedule);
    document.getElementById('loadBtn').addEventListener('click', loadSchedules);
    document.getElementById('clearBtn').addEventListener('click', () => {
        // Clear all UI inputs and state
        apiKeyInput.value = '';
        taskInput.value = '';
        // Output background uses rose-50
        scheduleOutput.innerHTML = `<h3 class="text-lg font-semibold text-gray-600 text-center">AI ìƒì„± ìŠ¤ì¼€ì¤„ì´ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.</h3>`;
        currentSchedule = [];
        achievementDisplay.classList.add('hidden');
        showStatus('ëª¨ë“  ë‚´ìš©ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤. (ì €ì¥ëœ ê¸°ë¡ì€ ìœ ì§€)');
    });


    // --- Initialization ---
    window.onload = () => {
        loadFeedbackHistory();
        console.log("App Initialized. Feedback history loaded for AI learning.");
        showStatus('âœ¨ í”Œë˜ë„ˆ ì¤€ë¹„ ì™„ë£Œ! Keyì™€ í•  ì¼ì„ ì…ë ¥í•˜ì„¸ìš”.');
    };
    
</script>

</body>
</html>
